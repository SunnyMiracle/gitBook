## 作用域是什么
变量的存储和访问给程序带了状态的概念，但是有些问题也是值得我们去明确的：
- 变量存储在哪里？
- 程序如何访问指定的变量？
因此需要一种规则来存储这些变量，并且之后可以方便的找到这些变量，这套规则就称之为"作用域"

### 编辑原理
通常我们将JavaScript称之为动态 或者 解释执行语言，但是事实上他也是一门编译语言。

传统编译型语言的编译过程：
- 分词/词法分析

    这个过程会把代码解析成有意义的代码块，这些代码块就是词法单元（token）,
    是否将空格作为词法单元，取决于空格在这个编程语言中是否有意义。

- 解析/语法分析

    这个过程会将由词法单元组成的词法单元流转成 抽象语法树（AST）

- 代码生成
    
    这个过程会把AST转成对应的目标代码，会根据目标平台的不同而不同。


javascript的编译过程发生执行阶段，同时要保证解释执行的速度。简单来说，任何JavaScript代码在执行前都需要经过编译，编译之后通常会马上执行。

### 理解作用域
- 引擎，从头到尾负责整个JavaScript程序的编译以及执行过程。
- 编译器，负责词法分析以及代码生成等工作。
- 作用域，负责收集并维护所有声明的标识符（变量），并组成一些列查询规则。
以下边代码为例进行简单说明：
```javascript
var a = 10;
```
首先编译器会查询作用域中是否有一个变量已经存在，并且在同一作用域集合中，如果是的话则会忽略 var a 这个声明，否则会要求作用域在当前作用域集合中声明一个变量，并命名为 a。

之后编译器会为引擎生成 运行时所需要的代码，这些代码用来处理 a = 10; 这个操作。引擎运行时会首先询问当前作用域是否存在变量a,如果是的话执行赋值操作。否的话会继续按照作用的查找规则进行查找。如果最后没有找到变量a则会抛出异常。

总而言之，变量的赋值操作会分解成两个动作，首先编译器会在当前作用域中声明一个变量，然后在运行时对该变量进行赋值操作。

PS: 上述代码中如果使用let进行变量声明，则解释器的运行规则会不同，如果在同一作用域中已经用了当前变量的声明，则会直接抛出异常。

### LHS查询 以及 RHS查询
LHS和RHS的含义为赋值操作的左侧或者右侧，并不一定意味着等号的左侧或者右侧。个人理解为：在给一个变量赋值的时候引擎会在作用域中查看当前变量是否存在，这个查询操作就是LHS,在表达式中或者函数执行中引擎需要查询指定变量的内容以及确定是否存在时就是用到了RHS查询。

这两种查询行为是不一样的：
- LHS查询在查询一个未声明的变量是，是不会报错的，而是在全局作用域声明这样一个变量。
- LHS查询到了一个指定的变量，直接返回当前变量。
- RHS查询在一个为声明的变量时，是直接报错处理。
- RHS查询得到的变量 如果对其进行不正确的操作时，引擎也会抛出类型异常的错误，TypeError.
- ES5之后的严格模式下禁止了LHS自动在全局变量声明变量的行为。

---

结合函数调用是参数值传递以及引用传递的特性(需要区分不同的数据结构)。

如果是基本数据类型，则是按照值传递。如果是复杂数据结构则是按照引用传递，函数形参只是一个指针，这个指针指向外部数据源。
```javascript
function foo(a) {
    a = 100;
    console.log(a);
}
let a = {
    name: 123,
};
foo(a); // 100
console.log(a); // { name: 123 }
```
上述现象就说明函数参数在复杂数据结构的时候，只是一个对外部对象的引用，函数内部改变这个引用的指向，并不会影响到外部数据。

这部分说了这么多其实就是想佐证 LHS查询返回的一定是变量的指针，也就是在内存中的地址。以及函数参数，为函数作用域中的变量，LHS查询总是会有值的，以及会正确的进行赋值操作。

---

补充示例代码：
```javascript

a = 100; // 非严格模式下会运行正常，严格模式下 ReferenceError: a is not defined

```
示例代码分析：
```javascript
function foo(a) {
    console.log(a + b); // 1
    b = a; // 2
}
foo(2);
```
- 引擎RHS查询 foo函数，作用域返回foo函数体。
- 引擎LHS查询foo函数形参a, 并且赋值为2。
- 引擎RHS查询console这个全局对象，并且拿到log函数。
- 引擎LHS查询变量a，发现是函数的形参，得到a的值。
- 引擎RHS查询变量b，并没有找到这个变量，抛出异常。

如果上边代码第一行与第二行的位置互换一下，会怎么样的？事实上位置互换之后可以正确执行了，并且打印出结果 4 。
原因在于第二行代码执行的时候是进行了LHS查询，发现没有变量b，则会在全局声明变量b，并且赋值，但是在严格模式下是会报错的。

### 总结
作用域是一套规则，用于确定在何处以及如何查找变量。如果查找的目的是为了赋值，则引擎会使用LHS查询，如果查询的目的是为了获取变量的值，就会使用RHS查询。

在执行var a = 10; 这样的语句时，JavaScript引擎首先会对其进行编译，并且会分成两个步骤进行执行：

1. 在作用域中对变量a进行声明。
2. 紧接着执行 a = 10; 这条语句，LHS查询操作，对其进行赋值。

作用域是有层次关系的，LHS以及RHS查询都会在当前作用域中对变量进行查询，在查询不到的情况下，会向上级进行查询，直到顶层作用域。

如果在顶层作用域中也没有找到该变量，RHS查询会直接抛出ReferenceError的异常，LHS在会隐式的在全局作用域中创建一个变量（非严格模式下）。