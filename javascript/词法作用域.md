## 词法作用域
作用域是一套规则，用来管理引擎如何在当前的作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

这个规则有两种工作模式，一种为最普遍的也是大多数编程语言所采用的的，词法作用域；另一种是动态作用域。
通俗来讲，词法作用域就是由你写的代码来决定的，编译器会保持你书写代码决定的作用域。
```javascript
function foo(a) {
  let b = a * 2;
  function bar(c) {
    console.log(a, b, c);
  }
  bar(b * 3);
}
foo(2);
```
上边代码中有三层逐级嵌套的作用域，第一层是全局作用域，定义了foo函数；第二层为函数foo创建的作用域，定义了b变量，bar函数，以及参数a；
第三层作用域为bar创建的，定义了参数c。

### 查找
对去上边的代码来说，console.log打印的三个变量，会进行逐级查找，由内而外，作用域查找会在找到第一个匹配的标识符停止。
在多层的嵌套作用域中，可以定义同名的标识符，这叫做 "遮蔽效应"。

词法作用域只会查找一级标识符，例如代码中引用了 foo.bar.baz, 词法作用域只会试图查找foo标识符，找到这个变量之后，对象属性
访问规则会分别接管对bar和baz的访问。

还需要注意的一点是，不论函数在哪里调用，也不论是如何被调用，他的词法作用域都只由函数被声明时所处的位置而决定。例如下边代码：
```javascript
var name = 'outer name';
function foo() {
  console.log(name);
}
function bar() {
  var name = 'bar name';
  foo();
}
bar();
```
执行上边的代码，打印出的结果应该是 outer name。

### 欺骗词法作用域
在JavaScript中，运行时的词法作用域是可以修改的，或者说是欺骗的，是如何实现呢，有两种机制，一种是eval，另一种是with。
大家普遍认为使用这两个语法不是什么好主意，一个重要的原因在于会导致程序的性能下降。

#### eval
eval函数可以接受一个字符串作为参数，并将字符串视为在程序执行位置上书写的代码内容。
```javascript
var a = 2;
function foo() {
  eval('var a = 3');
  console.log(a);
}
foo();
```
上边打印的结果为3，而不是2。

eval的主要作用是可以动态的执行JavaScript代码，这也是其意义所在，但是很多情况下弊大于利。
在严格模式下eval函数会有其子集的作用域，不会影响到外部。

与eval函数类似的功能实现，还是可以通过new Function(...)的方式实现，因为实例化出来的函数有自身的函数级作用域，因此会比eval()更加安全。
```javascript
function foo() {
  const fn = new Function('', 'a = 3;');
  fn();
  console.log(a);
}
foo();
```
上边代码中，也是可以正确打印出变量a的值，原因是因为a这个变量是全局作用域，如果前边加 var 进行函数声明的话，则会报错。

#### with 
不推荐使用，不做介绍。

前边有提到，改变词法作用域是会导致性能下降，这是因为JavaScript引擎在词法分析阶段会根据代码编写时确定的词法作用域做一些性能上的
优化，但是代码中如果存在eval这些存在的时候，会导致引擎无法确定函数执行之后会如何改变，所以就不会做优化，从而导致运行变慢。

