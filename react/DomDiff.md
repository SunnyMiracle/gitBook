传统 树 的diff算法是通过循环递归对节点依次进行比较，效率低下，通常时间复杂度为O(n^3);

在React中，也是需要对DOM 树进行diff比较，从而知道哪里更新，通过优化复杂度为O(n)。优化策略为：

- 跨层级的DOM操作都很少，可以忽略不计。
- 拥有相同类的两个组件将会有相似的虚拟DOM的树形结构，不同类则会有不同的树形结构。
- 对于同一层级，同一类的组件列表，可以设置唯一的id （key）加以区分。

所以通俗的描述就是：

- virtual Dom 新旧直接的比较只是在同一层级进行比较，React内部会维护树的层级关系。因此即使上一层级的DOM搬移到了
下一层级，也不会产生实际的搬移操作，而只是简单的删除，新建。因此在实际开发中，应该尽量保证DOM树结构的稳定，可以通过css来控制组件的显隐。
- 同一层级之间比较，如果发现发现是同一类型的组件，则会按照上一步的虚拟DOM的比较规则继续进行比较。如果发现不是同一类型的组件
则会直接标记为dirty DOM，从而组件内部的虚拟DOM则不会进行比较，全部替换。
- 需要注意的一点是，如果同一层级 也是同一类的实例组件的话，如果前后props发生了改变，同时如果我们清楚的知道组件下的虚拟DOM
没有发生改变，可以明确在 shouldComponentUpdate() 中增加逻辑，需要注意的是不能再这一步进行非常耗时的操作，会影响性能。
- 对于同一层级同一类组件组成的列表而言，可以指定一个key，是一种中顺序优化手段，可以做到大多数情况下做到最少数据搬移，
内部维护一个lastIndex的变量，并且与组件在旧列表中的下标索引（mountIndex）如果mountIndex < lastIndex 则进行搬移，否则不进行搬移。
因此要避免将最后一个元素移动到第一个元素这种操作，因此这种回到值整个列表的元素都会进行一次搬移。

### React Patch
批量更新。将diff之后的虚拟dom 的差异队列更新到真实的DOM中。

### 组件性能优化

#### Immutable数据
上边提到如果同一类型的组件，在数据未发生变化，明确知道虚拟DOM没有更新的话，可以设置shouldComponentUpdate，但是由于对象是基于引用，当然我们
可以通过有深拷贝、深比较来判断数据是否真的发生改变，是否需要比较节点下的虚拟DOM，但是如果使用Imutable数据的话，成本可以降到最低。
